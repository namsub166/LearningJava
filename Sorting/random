/**
	 * Determine if the values in nums can be split into two groups where
	 * the sum of one is a non-zero multiple of 10 and the sum of the other
	 * is odd.
	 * 
	 * @param nums the numbers.
	 * @return true if it is possible, false if not.
	 */
	public static boolean splitOdd10(int[] nums) {
		return splitOdd10(nums,0,0,0);
	}
	
	/**
	 * A helper method for the previous method.
	 * Determine if the values in nums can be split into two groups where
	 * the sum of one is a non-zero multiple of 10 and the sum of the other
	 * is odd.
	 * 
	 * @param nums the numbers
	 * @param index the current index in the array
	 * @param sumOfGroup1 sum of numbers in group 1
	 * @param sumOfGroup2 sum of numbers in group 2
	 * @return true if it is possible, false if not.
	 */
	public static boolean splitOdd10(int[] nums, int index, int sumOfGroup1, int sumOfGroup2){
		if (index == nums.length){
			if (sumOfGroup1 == 0 || sumOfGroup2 == 0) return false;
			else return (sumOfGroup1 % 10 == 0 && sumOfGroup2 % 2 == 1) || (sumOfGroup2 % 10 == 0 && sumOfGroup2 % 2 == 1);
		} else {
			if (splitOdd10(nums, index + 1, sumOfGroup1 + nums[index], sumOfGroup2)) return true;
			else if (splitOdd10(nums, index + 1, sumOfGroup1, sumOfGroup2 + nums[index])) return true;
			else return false;
		}	
	}
  
  public static ArrayList<String> combinations(String s, int k) {
		ArrayList<String> result = new ArrayList<>();
		if (s.length() < k){
			return result;
		} else if (k == 0){
			return result;
		} else if (s.length() == 1){
			// in this case k = 1 as well, since k must less than and equal to s.length()
			// and we already check k = 0.
			result.add(s);
			return result;
		} else {
			//Main argument
			String curChar = Character.toString(s.charAt(0));
			ArrayList<String> array1 = combinations(curChar, s.substring(1), k-1);
			ArrayList<String> array2 = combinations(s.substring(1), k);
			array1.addAll(array2);
			return array1;
		}
	}

	/**
	 * Recursive Problem Transformation:
	 * 
	 * Generate all combinations of length k of the characters in rest prefixed
	 * with the characters in prefix. This is very similar to the subset method!
	 * 
	 * <code> 
	 * For example: 
	 *   combinations("", "ABC") -> "" before {AB, AC, BC}
	 *                           -> {AB, AC, BC}
	 *                      
	 *   combinations("A", "BC") -> A before {BC, B, C, ""} 
	 *                           -> {AB, AC} 
	 *                           
	 *   combinations("", "BC")  -> "" before {BC, B, C, ""} 
	 *                           -> {BC}
	 * </code>
	 */
	private static ArrayList<String> combinations(String prefix, String rest,
			int k) {
		recusiveCalls++;
		ArrayList<String> result = new ArrayList<>();
		if (rest.length() < k){
			return result;
		} else if (k == 0){
			result.add(prefix);
			return result;
		} else if (rest.length() == 1){
			// in this case k == 1 as well, since k must less than and equal to rest.length()
			// and we already check k = 0.
			result.add(prefix + rest);
			return result;
		} else {
			ArrayList<String> array1 = combinations(prefix, rest.substring(1), k);
			String newPrefix = prefix + Character.toString(rest.charAt(0));
			ArrayList<String> array2 = combinations(newPrefix, rest.substring(1), k-1);
			array1.addAll(array2);
			return array1;
		}
	}
  
